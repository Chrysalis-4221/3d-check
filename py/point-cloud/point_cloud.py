
import sys
import numpy as np
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog
from PyQt5.QtCore import Qt
import open3d as o3d
from scipy.optimize import least_squares
from scipy.spatial import Delaunay

class Open3DVisualizer:
    def __init__(self, parent=None):
        self.pointCloud = None
        self.mesh = None
        self.parent = parent

    def setPointCloud(self, pointCloud):
        self.pointCloud = pointCloud
        self.updateView()

    def setMesh(self, mesh):
        self.mesh = mesh
        self.updateView()

    def updateView(self):
        if self.parent is not None:
            self.parent.update()

class PreviewWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.visualizer = Open3DVisualizer(self)
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Preview"))
        self.setLayout(layout)

    def setPointCloud(self, pointCloud):
        self.visualizer.setPointCloud(pointCloud)

    def setMesh(self, mesh):
        self.visualizer.setMesh(mesh)

    def paintEvent(self, event):
        if self.visualizer.pointCloud is not None:
            o3d.visualization.draw_geometries([self.visualizer.pointCloud])
        elif self.visualizer.mesh is not None:
            o3d.visualization.draw_geometries([self.visualizer.mesh])

class PointCloudProcessor:
    def loadPointCloud(self, filename):
        pointCloud = o3d.io.read_point_cloud(filename)
        return pointCloud

    def processPointCloud(self, pointCloud):
        # ?????????? ????????? ??????????-?????????? ??? ??????????? ?????????? ?????? ? ????????? ????????? ?????
        points = np.asarray(pointCloud.points)
        initial_params = np.zeros(6)  # ????????? ??????????? ?????????? ??????
        optimized_params = least_squares(self.reprojectionError, initial_params, args=(points,)).x
        pointCloud.points = o3d.utility.Vector3dVector(self.updatePoints(points, optimized_params))

        # ????????????? ???????????? ??????? ??????? ??? ?????????? ? ??????????? ????????? ?????
        kf = self.ExtendedKalmanFilter(pointCloud.points)
        smoothed_points = kf.smooth()
        pointCloud.points = o3d.utility.Vector3dVector(smoothed_points)

        # ?????????? ????????? ???????????? ?????? ??????? ?????????? ?????? ??? ?????????? ????? ?????????????
        mesh = self.delaunayTriangulation(pointCloud)

        return mesh

    def reprojectionError(self, params, points):
        # ?????????? ?????? ?????????? ????? ???????????? ? ?????????????? ???????????? ?????
        predicted_points = self.projectPoints(points, params)
        errors = predicted_points - points
        return errors.ravel()

    def projectPoints(self, points, params):
        # ??????? ???????? ????? ? ?????????????? ?????????? ??????
        focal_length = params[0]
        principal_point = params[1:3]
        distortion_coeffs = params[3:]

        # ?????????? ?????? ?????? ??? ???????? ?????
        projected_points = np.zeros_like(points)
        for i in range(points.shape[0]):
            x, y, z = points[i]
            x_norm = (x - principal_point[0]) / focal_length
            y_norm = (y - principal_point[1]) / focal_length
            r_squared = x_norm**2 + y_norm**2
            r_distortion = 1 + distortion_coeffs[0] * r_squared + distortion_coeffs[1] * r_squared**2
            x_proj = x_norm * r_distortion
            y_proj = y_norm * r_distortion
            projected_points[i] = [x_proj * focal_length + principal_point[0],
                                   y_proj * focal_length + principal_point[1],
                                   z]

        return projected_points

    def updatePoints(self, points, params):
        # ??????? ?????????? ????????? ????? ?? ?????? ???????????????? ?????????? ??????
        focal_length = params[0]
        principal_point = params[1:3]
        distortion_coeffs = params[3:]

        # ???????? ???????? ????? ? ?????????????? ???????????????? ?????????? ??????
        updated_points = np.zeros_like(points)
        for i in range(points.shape[0]):
            x, y, z = points[i]
            x_norm = (x - principal_point[0]) / focal_length
            y_norm = (y - principal_point[1]) / focal_length
            r_squared = x_norm**2 + y_norm**2
            r_distortion = 1 + distortion_coeffs[0] * r_squared + distortion_coeffs[1] * r_squared**2
            x_proj = x_norm / r_distortion
            y_proj = y_norm / r_distortion
            updated_points[i] = [x_proj * focal_length + principal_point[0],
                                 y_proj * focal_length + principal_point[1],
                                 z]

        return updated_points

    class ExtendedKalmanFilter:
        def __init__(self, points):
            self.points = points
            self.state_size = 3  # ??????????? ??????? ????????? (x, y, z)
            self.meas_size = 3  # ??????????? ??????? ????????? (x, y, z)
            self.process_noise_cov = np.eye(self.state_size) * 0.001  # ?????????????? ??????? ???? ????????
            self.meas_noise_cov = np.eye(self.meas_size) * 0.01  # ?????????????? ??????? ???? ?????????
            self.state = np.zeros((self.state_size, 1))  # ?????? ?????????
            self.cov = np.eye(self.state_size)  # ?????????????? ???????

        def predict(self):
            # ??????? ???????????? ????????? ?? ?????? ??????????? ?????????
            self.state = self.state  # ????????????, ??? ????????? ?? ??????????
            self.cov = self.cov + self.process_noise_cov
            return self.state

        def update(self, observation):
            # ??????? ?????????? ????????? ? ?????? ??????????
            observation = observation.reshape((-1, 1))
            innovation = observation - self.state
            innovation_cov = self.cov + self.meas_noise_cov
            kalman_gain = np.dot(self.cov, np.linalg.inv(innovation_cov))
            self.state = self.state + np.dot(kalman_gain, innovation)
            self.cov = self.cov - np.dot(kalman_gain, self.cov)
            return self.state

        def smooth(self):
            # ??????? ??????????? ????????? ????? ? ?????????????? ???????????? ??????? ???????
            smoothed_points = []
            for point in self.points:
                self.state = point.reshape((-1, 1))
                predicted_state = self.predict()
                smoothed_state = self.update(point)
                smoothed_point = smoothed_state.flatten()
                smoothed_points.append(smoothed_point)
            return smoothed_points

    def delaunayTriangulation(self, pointCloud):
        # ?????????? ????????? ???????????? ?????? ??????? ?????????? ??????
        points = np.asarray(pointCloud.points)
        tri = Delaunay(points[:, :2])  # ???????????? ?? ?????? ????????? X ? Y

        # ???????? ????? ?????????????
        triangles = tri.simplices
        vertices = points[tri.vertices]
        mesh = o3d.geometry.TriangleMesh()
        mesh.vertices = o3d.utility.Vector3dVector(vertices)
        mesh.triangles = o3d.utility.Vector3iVector(triangles)

        return mesh

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Point Cloud Processing")

        centralWidget = QWidget()
        layout = QHBoxLayout()

        self.leftPreview = PreviewWidget()
        self.rightPreview = PreviewWidget()

        layout.addWidget(self.leftPreview)
        layout.addWidget(self.rightPreview)

        self.loadButton = QPushButton("Load Point Cloud")
        self.loadButton.clicked.connect(self.loadPointCloud)

        self.processButton = QPushButton("Process Point Cloud")
        self.processButton.clicked.connect(self.processPointCloud)

        self.statusLabel = QLabel()
        self.statusLabel.setAlignment(Qt.AlignCenter)

        controlLayout = QVBoxLayout()
        controlLayout.addWidget(self.loadButton)
        controlLayout.addWidget(self.processButton)
        controlLayout.addWidget(self.statusLabel)

        layout.addLayout(controlLayout)

        centralWidget.setLayout(layout)
        self.setCentralWidget(centralWidget)

        self.processor = PointCloudProcessor()

    def loadPointCloud(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Point Cloud", "", "OBJ Files (*.obj)")
        if filename:
            pointCloud = self.processor.loadPointCloud(filename)
            self.leftPreview.setPointCloud(pointCloud)
            self.updateStatus("Point cloud loaded successfully.")

    def processPointCloud(self):
        pointCloud = self.leftPreview.visualizer.pointCloud
        if pointCloud is not None:
            self.updateStatus("Processing point cloud...")
            mesh = self.processor.processPointCloud(pointCloud)
            self.rightPreview.setMesh(mesh)
            self.updateStatus("Point cloud processed successfully.")
        else:
            self.updateStatus("No point cloud loaded.")

    def updateStatus(self, message):
        self.statusLabel.setText(message)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    sys.exit(app.exec_())